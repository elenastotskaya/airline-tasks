# Обработка строк с кодами авиарейсов
Оба задания выполнены с использованием регулярных выражений, так как это представляется логичным способом обработки строк с форматом, имеющим несколько вариаций.
Шаблон корректного кода имеет вид  
`(?=.{1,7}$)(((?=.{2,3}\d)(([A-Z]\d|[A-Z][A-Z][A-Z]?|\d[A-Z])\ ?))?((?=.{1,5}$)((0*)(\d+))))`  
Первый блок ограничивает общее число символов, так как сам по себе шаблон допускает слишком большое число (например, 3 буквы и 5 цифр).  
На блок, отвечающий за код авиакомпании, накладывается дополнительное ограничение длины, чтобы исключить вариант "3 буквы + пробел". Код без пробела выделен отдельными скобками, чтобы его можно было автоматически находить как подстроку с помощью функции `regex_match`.  
На номер рейса также накладывается ограничение длины. Кроме того, номер разбивается на две части, чтобы отбросить все ведущие нули. Если номер состоит из одних нулей (в задании не указано, может ли существовать такой номер), в строке останется один ноль, и номер так же можно будет сравнивать с другими номерами, и даже в случае отсутствия кода авиакомпании строка не станет пустой.

Решение задания 1 состоит только из функции сравнения, функции для отладочной печати и простой функции `main` для тестирования. В функции сравнения к обеим строкам применяется `regex_match`, после чего (в случае, если коды корректные и `regex_match` вернул не пустую строку) отдельно сравниваются подстроки, отвечающие за код авиакомпании и номер рейса без лишних символов. Если обе этих подстроки совпадают, коды можно считать одинаковыми.

В решении задачи 2 для исключения дубликатов используется контейнер `unordered_set`, так как он хранит только уникальные значения. Функция `main` создает второй поток, в котором выполняется функция обработки для файлов `1_in` и `1_out`, а затем также вызывает функцию обработки для файлов `2_in` и `2_out`. Так как потоки выполняются независимо и не требуют дополнительных действий для синхронизации, одним из потоков обработки может быть сам основной поток, для экономии ресурсов. Если все файлы были корректно открыты или созданы, в каждом из потоков создается `unordered_set`, в который будут добавляться строки, считанные из входного файла. Перед добавлением в контейнер строка обрабатывается функцией `trimFlightCode`. Эта функция с помощью того же регулярного выражения, как в первом задании, выделяет код авиакомпании и номер рейса без лишних необязательных символов и возвращает строку, состоящую только из этих двух частей. Такое приведение к "стандартному" виду гарантирует, что две строки, содержащие одинаковые коды, станут полностью одинаковыми и не будут обе добавлены в контейнер. Если же считанная строка оказывается некорректной (не соответствующей формату кода и номера рейса и не возвращающей совпадений с регулярным выражением), функция `trimFlightCode` возвращает пустую строку. Перед добавлением обработанной строки в контейнер добавлена проверка, что строка не пустая. После того, как все строки из входного файла добавлены в unordered_set, все его элементы выводятся в выходной файл.

В задании не уточняется, как должна выполняться обработка ошибок и нужно ли предполагать, что полученные строки могут не соответствовать шаблону. Поэтому на данный момент при большей части ошибок (таких как проблемы с открытием файла) просто выводится сообщение в `std::cerr`, в первом задании некорректные строки всегда считаются неравными (и также выводится сообщение), а во втором некорректные данные, полученные из файла, просто игнорируются. Логика программы позволяет использовать другие способы обработки ошибок - например, если в проекте используются исключения, можно выбрасывать исключение в случае, если `regex_match` возвращает пустую строку.
